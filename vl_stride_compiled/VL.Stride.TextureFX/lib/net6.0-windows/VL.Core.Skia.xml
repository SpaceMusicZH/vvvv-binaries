<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VL.Core.Skia</name>
    </assembly>
    <members>
        <member name="T:VL.Skia.CallerInfo">
            <summary>
            Information from downstream that gets handed over to upstream on render and on notify. Immutable
            </summary>
        </member>
        <member name="M:VL.Skia.CallerInfo.InRenderer(System.Single,System.Single,SkiaSharp.SKCanvas,SkiaSharp.GRContext)">
            <summary>
            Renderers call this to set up the caller info
            </summary>
        </member>
        <member name="M:VL.Skia.CallerInfo.WithRenderPaintHack(System.Func{System.Object,System.Object})">
            <summary>
            Use this to implement semantics-like features.
            With the delegate you can influence all rendering nodes upstream.
            </summary>
        </member>
        <member name="M:VL.Skia.CallerInfoExtensions.PushTransformation(VL.Skia.CallerInfo,SkiaSharp.SKMatrix)">
            <summary>
            Adjust the space for upstream - based on the downstream tranformation.
            Can be used by cameras or normal object to world space transformations.
            Adjust the camera further downstream to make it work as expected.
            </summary>
        </member>
        <member name="M:VL.Skia.CallerInfoExtensions.InViewport(VL.Skia.CallerInfo,SkiaSharp.SKRect,System.Func{VL.Skia.CallerInfo,SkiaSharp.SKMatrix})">
            <summary>
            Setup a new viewport.
            If we are already in a viewport this places the new viewport inside the downstream viewport.
            </summary>
        </member>
        <member name="M:VL.Skia.CallerInfoExtensions.GetWithinSpaceTransformation(SkiaSharp.SKRect,VL.Skia.Sizing,System.Single,System.Single,VL.Lib.Mathematics.RectangleAnchor)">
            <summary>
            Applies the space by resetting the Transformation.
            Further upstream you may use cameras and other transformations and thus invent your own space.
            </summary>
        </member>
        <member name="F:VL.Skia.CommonSpace.Normalized">
            <summary>
            Height goes from -1 Top to 1 Bottom. The origin is located in the center.
            </summary>
        </member>
        <member name="F:VL.Skia.CommonSpace.DIP">
            <summary>
            Works with device independant pixels. One unit equals 100 actual DIP. The origin is located in the center.
            </summary>
        </member>
        <member name="F:VL.Skia.CommonSpace.DIPTopLeft">
            <summary>
            Works with device independant pixels. One unit equals 100 actual DIP. The origin is located at the top left.
            </summary>
        </member>
        <member name="F:VL.Skia.CommonSpace.PixelTopLeft">
            <summary>
            Works with pixels. One unit equals 100 actual pixels. The origin is located at the top left.
            </summary>
        </member>
        <member name="T:VL.Skia.Sizing">
            <summary>
            Allows to adjust the units of the coordinate space 
            </summary>
        </member>
        <member name="F:VL.Skia.Sizing.Pixels">
            <summary>
            Pixel space. One unit equals 100 acutal pixels.  
            </summary>
        </member>
        <member name="F:VL.Skia.Sizing.DIP">
            <summary>
            Device Independant Pixels are like pixels, but respect the scaling factor of the display. One unit equals 100 actual DIP.
            </summary>
        </member>
        <member name="F:VL.Skia.Sizing.ManualSize">
            <summary>
            Adjust with and height manually. 
            Setting either width or height to 0 results in computing width depending on height or vice versa, 
            while respecting the aspect ratio of the renderer or viewport.
            </summary>
        </member>
        <member name="T:VL.Skia.ILayer">
            <summary>
            Scene graph nodes may 
            * render themselves into the layer
            * react on or modify notifications from downstream 
            </summary>
        </member>
        <member name="M:VL.Skia.ILayer.Render(VL.Skia.CallerInfo)">
            <summary>
            Renders the layer. Called from downstream. 
            Scene graph elements should render themselves before calling render upstream.
            </summary>
        </member>
        <member name="M:VL.Skia.ILayer.Notify(VL.Lib.IO.Notifications.INotification,VL.Skia.CallerInfo)">
            <summary>
            Scene graph nodes typically notify upstream before considering to apply own logic.
            Typically only apply own logic if notification didn't get processed by upstream. 
            Return if notification got processed.
            </summary>
        </member>
        <member name="P:VL.Skia.ILayer.Bounds">
            <summary>
            The Bounds of the rendering
            </summary>
        </member>
        <member name="T:VL.Skia.IRendering">
            <summary>
            Allows to concentrate on the rendering of a single layer. 
            No need for calling anything upstream, no need to think about notifications.
            </summary>
        </member>
        <member name="M:VL.Skia.IRendering.Render(VL.Skia.CallerInfo)">
            <summary>
            Renders the layer. 
            </summary>
        </member>
        <member name="P:VL.Skia.IRendering.Bounds">
            <summary>
            The Bounds of the rendering
            </summary>
        </member>
        <member name="T:VL.Skia.IBehavior">
            <summary>
            Allows to concentrate on the behavior of a single layer. 
            No need for calling anything upstream, no need to think about rendering.
            </summary>
        </member>
        <member name="M:VL.Skia.IBehavior.Notify(VL.Lib.IO.Notifications.INotification,VL.Skia.CallerInfo)">
            <summary>
            If notification got processed return true.
            </summary>
        </member>
        <member name="M:VL.Skia.RenderContext.ForCurrentThread">
            <summary>
            Returns the render context for the current thread.
            </summary>
            <returns>The render context for the current thread.</returns>
        </member>
        <member name="P:VL.Skia.RenderStopwatch.RenderTime">
            <summary>
            The time between StartRender and EndRender in Î¼s.
            </summary>
        </member>
        <member name="T:Windows.Win32.Foundation.PCWSTR">
            <summary>
            A pointer to a null-terminated, constant character string.
            </summary>
        </member>
        <member name="F:Windows.Win32.Foundation.PCWSTR.Value">
            <summary>
            A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
            </summary>
        </member>
        <member name="P:Windows.Win32.Foundation.PCWSTR.Length">
            <summary>
            Gets the number of characters up to the first null character (exclusive).
            </summary>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.ToString">
            <summary>
            Returns a <see langword="string"/> with a copy of this character array, up to the first null character (exclusive).
            </summary>
            <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="F:Windows.Win32.Foundation.PCWSTR.Value"/> is <see langword="null"/>.</returns>
        </member>
        <member name="M:Windows.Win32.Foundation.PCWSTR.AsSpan">
            <summary>
            Returns a span of the characters in this string, up to the first null character (exclusive).
            </summary>
        </member>
        <member name="T:Windows.Win32.FreeLibrarySafeHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:Windows.Win32.PInvoke.FreeLibrary(Windows.Win32.Foundation.HMODULE)"/>.
            </summary>
        </member>
        <member name="T:Windows.Win32.PInvoke">
            <content>
            Contains extern methods from "KERNEL32.dll".
            </content>
            <content>
            Contains extern methods from "USER32.dll".
            </content>
        </member>
        <member name="M:Windows.Win32.PInvoke.FreeLibrary(Windows.Win32.Foundation.HMODULE)">
            <summary>Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count.</summary>
            <param name="hLibModule">
            <para>A handle to the loaded library module. The <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> function returns this handle.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
            </returns>
            <remarks>
            <para>The system maintains a per-process reference count for each loaded module. A  module that was loaded at process initialization due to load-time dynamic linking has a reference count of one. The reference count for a module is incremented each time the  module is loaded by a call to <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>. The reference count is also incremented by a call to <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a> unless the  module  is being loaded for the first time and is being loaded as   a data or image file. The reference count is decremented each time the <b>FreeLibrary</b> or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> function is called for the module. When a  module's reference count reaches zero or the process terminates, the system unloads the module from the address space of the  process. Before unloading a library module, the system enables the module to detach from the process by calling the module's <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a> function, if it has one, with the DLL_PROCESS_DETACH value. Doing so gives the library module an opportunity to clean up resources allocated on behalf of the current process. After the entry-point function returns, the library module is removed from the address space of the current process. It is not safe to call <b>FreeLibrary</b> from <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a>. For more information, see the Remarks section in <a href="https://docs.microsoft.com/windows/desktop/Dlls/dllmain">DllMain</a>. Calling <b>FreeLibrary</b> does not affect other processes that are using the same module. Use caution when calling <b>FreeLibrary</b> with a handle returned by <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>. The <b>GetModuleHandle</b> function does not increment a module's reference count, so passing this handle to <b>FreeLibrary</b> can cause a module to be unloaded prematurely. A thread that must unload the DLL in which it is executing and then terminate itself should call <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a> instead of calling <b>FreeLibrary</b> and <b>ExitThread</b> separately. Otherwise, a race condition can occur. For details, see the Remarks section of <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread">FreeLibraryAndExitThread</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-freelibrary#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetModuleHandle(System.String)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.GetModuleHandle(Windows.Win32.Foundation.PCWSTR)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetModuleHandle(Windows.Win32.Foundation.PCWSTR)">
            <summary>Retrieves a module handle for the specified module. The module must have been loaded by the calling process. (Unicode)</summary>
            <param name="lpModuleName">
            <para>The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
            <para>If this parameter is NULL, <b>GetModuleHandle</b> returns a handle to the file used to create the calling process (.exe file). The <b>GetModuleHandle</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the specified module. If the function fails, the return value is NULL. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>The returned handle is not global or inheritable. It cannot be duplicated or used by another process. If <i>lpModuleName</i> does not include a path and there is more than one loaded module with the same base name and extension, you cannot predict which module handle will be returned. To work around this problem, you could specify a path, use <a href="https://docs.microsoft.com/windows/desktop/Msi/side-by-side-assemblies">side-by-side assemblies</a>, or use <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> to specify a memory location rather than a DLL name. The <b>GetModuleHandle</b> function returns a handle to a mapped module without incrementing its reference count. However, if this handle is passed to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibrary">FreeLibrary</a> function, the reference count of the mapped module will be decremented. Therefore, do not pass a handle returned by <b>GetModuleHandle</b> to the <b>FreeLibrary</b> function. Doing so can cause a DLL module to be unmapped prematurely. This function must be used carefully in a multithreaded application. There is no guarantee that the module handle remains valid between the time this function returns the handle and the time it is used. For example, suppose that a thread retrieves a module handle, but before it uses the handle, a second thread frees the module. If the system loads another module, it could reuse the module handle that was recently freed. Therefore, the first thread would have a handle to a different module  than the one intended.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlew#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DestroyMenu(Windows.Win32.UI.WindowsAndMessaging.HMENU)">
            <summary>Destroys the specified menu and frees any memory that the menu occupies.</summary>
            <param name="hMenu">
            <para>Type: <b>HMENU</b> A handle to the menu to be destroyed.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-destroymenu#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>Before closing, an application must use the <b>DestroyMenu</b> function to destroy a menu not assigned to a window. A menu that is assigned to a window is automatically destroyed when the application closes. <b>DestroyMenu</b> is recursive, that is, it will destroy the menu and all its submenus.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-destroymenu#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.CreateWindowEx(Windows.Win32.UI.WindowsAndMessaging.WINDOW_EX_STYLE,System.String,System.String,Windows.Win32.UI.WindowsAndMessaging.WINDOW_STYLE,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.HWND,System.Runtime.InteropServices.SafeHandle,System.Runtime.InteropServices.SafeHandle,System.Void*)">
            <inheritdoc cref="M:Windows.Win32.PInvoke.CreateWindowEx(Windows.Win32.UI.WindowsAndMessaging.WINDOW_EX_STYLE,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.UI.WindowsAndMessaging.WINDOW_STYLE,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.HWND,Windows.Win32.UI.WindowsAndMessaging.HMENU,Windows.Win32.Foundation.HINSTANCE,System.Void*)"/>
        </member>
        <member name="M:Windows.Win32.PInvoke.CreateWindowEx(Windows.Win32.UI.WindowsAndMessaging.WINDOW_EX_STYLE,Windows.Win32.Foundation.PCWSTR,Windows.Win32.Foundation.PCWSTR,Windows.Win32.UI.WindowsAndMessaging.WINDOW_STYLE,System.Int32,System.Int32,System.Int32,System.Int32,Windows.Win32.Foundation.HWND,Windows.Win32.UI.WindowsAndMessaging.HMENU,Windows.Win32.Foundation.HINSTANCE,System.Void*)">
            <summary>Creates an overlapped, pop-up, or child window with an extended window style; otherwise, this function is identical to the CreateWindow function. (Unicode)</summary>
            <param name="dwExStyle">
            <para>Type: <b>DWORD</b> The extended window style of the window being created. For a list of possible values, see  <a href="https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles">Extended Window Styles</a>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpClassName">
            <para>Type: <b>LPCTSTR</b> A <b>null</b>-terminated string or a class atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero. If <i>lpClassName</i> is a string, it specifies the window class name. The class name can be any name registered with <b>RegisterClass</b> or <b>RegisterClassEx</b>, provided that the module that registers the class is also the module that creates the window. The class name can also be any of the predefined <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-window-classes">system class</a> names.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpWindowName">
            <para>Type: <b>LPCTSTR</b> The window name. If the window style specifies a title bar, the window title pointed to by <i>lpWindowName</i> is displayed in the title bar. When using <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create controls, such as buttons, check boxes, and static controls, use <i>lpWindowName</i> to specify the text of the control. When creating a static control with the <b>SS_ICON</b> style, use <i>lpWindowName</i> to specify the icon name or identifier. To specify an identifier, use the syntax "#<i>num</i>".</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="dwStyle">
            <para>Type: <b>DWORD</b> The style of the window being created. This parameter can be a combination of the <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-styles">window style values</a>, plus the control styles indicated in the Remarks section.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="X">
            <para>Type: <b>int</b> The initial horizontal position of the window. For an overlapped or pop-up window, the <i>x</i> parameter is the initial x-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>x</i> is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent window's client area. If <i>x</i> is set to <b>CW_USEDEFAULT</b>, the system selects the default position for the window's upper-left corner and ignores the <i>y</i> parameter. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if it is specified for a pop-up or child window, the <i>x</i> and <i>y</i> parameters are set to zero.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="Y">
            <para>Type: <b>int</b> The initial vertical position of the window. For an overlapped or pop-up window, the <i>y</i> parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>y</i> is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left corner of the parent window's client area. For a list box <i>y</i> is the initial y-coordinate of the upper-left corner of the list box's client area relative to the upper-left corner of the parent window's client area.</para>
            <para>If an overlapped window is created with the <b>WS_VISIBLE</b> style bit set and the <i>x</i> parameter is set to <b>CW_USEDEFAULT</b>, then the <i>y</i> parameter determines how the window is shown. If the <i>y</i> parameter is <b>CW_USEDEFAULT</b>, then the window manager calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> with the <b>SW_SHOW</b> flag after the window has been created. If the <i>y</i> parameter is some other value, then the window manager calls <b>ShowWindow</b> with that value as the <i>nCmdShow</i> parameter.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="nWidth">
            <para>Type: <b>int</b> The width, in device units, of the window. For overlapped windows, <i>nWidth</i> is the window's width, in screen coordinates, or <b>CW_USEDEFAULT</b>. If <i>nWidth</i> is <b>CW_USEDEFAULT</b>, the system selects a default width and height for the window; the default width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial y-coordinate to the top of the icon area. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if <b>CW_USEDEFAULT</b> is specified for a pop-up or child window, the <i>nWidth</i> and <i>nHeight</i> parameter are set to zero.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="nHeight">
            <para>Type: <b>int</b> The height, in device units, of the window. For overlapped windows, <i>nHeight</i> is the window's height, in screen coordinates. If the <i>nWidth</i> parameter is set to <b>CW_USEDEFAULT</b>, the system ignores <i>nHeight</i>.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hWndParent">
            <para>Type: <b>HWND</b> A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid window handle. This parameter is optional for pop-up windows. To create a <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">message-only window</a>, supply <b>HWND_MESSAGE</b> or a handle to an existing message-only window.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hMenu">
            <para>Type: <b>HMENU</b> A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, <i>hMenu</i> identifies the menu to be used with the window; it can be <b>NULL</b> if the class menu is to be used. For a child window, <i>hMenu</i> specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The application determines the child-window identifier; it must be unique for all child windows with the same parent window.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="hInstance">
            <para>Type: <b>HINSTANCE</b> A handle to the instance of the module to be associated with the window.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <param name="lpParam">
            <para>Type: <b>LPVOID</b> Pointer to a value to be passed to the window through the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-createstructa">CREATESTRUCT</a> structure (<b>lpCreateParams</b> member) pointed to by the <i>lParam</i> param of the <b>WM_CREATE</b> message.  This message is sent to the created window by this function before it returns. If an application calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create a MDI client window, <i>lpParam</i> should point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-clientcreatestruct">CLIENTCREATESTRUCT</a> structure. If an MDI client window calls <b>CreateWindow</b> to create an MDI child window, <i>lpParam</i> should point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-mdicreatestructa">MDICREATESTRUCT</a> structure. <i>lpParam</i> may be <b>NULL</b> if no additional data is needed.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>HWND</b> If the function succeeds, the return value is a handle to the new window. If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. This function typically fails for one of the following reasons: </para>
            <para>This doc was truncated.</para>
            </returns>
            <remarks>
            <para>The <b>CreateWindowEx</b> function sends <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccreate">WM_NCCREATE</a>, <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccalcsize">WM_NCCALCSIZE</a>, and <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-create">WM_CREATE</a> messages to the window being created. If the created window is a child window, its default position is at the bottom of the Z-order. If the created window is a top-level window, its default position is at the top of the Z-order (but beneath all topmost windows unless the created window is itself topmost). For information on controlling whether the Taskbar displays a button for the created window, see <a href="https://docs.microsoft.com/windows/desktop/shell/taskbar">Managing Taskbar Buttons</a>. For information on removing a window, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroywindow">DestroyWindow</a> function. The following predefined control classes can be specified in the <i>lpClassName</i> parameter. Note the corresponding control styles you can use in the <i>dwStyle</i> parameter. </para>
            <para>This doc was truncated.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.DestroyWindow(Windows.Win32.Foundation.HWND)">
            <summary>Destroys the specified window.</summary>
            <param name="hWnd">
            <para>Type: <b>HWND</b> A handle to the window to be destroyed.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-destroywindow#parameters">Read more on docs.microsoft.com</see>.</para>
            </param>
            <returns>
            <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
            </returns>
            <remarks>
            <para>A thread cannot use <b>DestroyWindow</b> to destroy a window created by a different thread. If the window being destroyed is a child window that does not have the <b>WS_EX_NOPARENTNOTIFY</b> style, a <a href="https://docs.microsoft.com/windows/win32/inputmsg/wm-parentnotify">WM_PARENTNOTIFY</a> message is sent to the parent.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-destroywindow#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
        <member name="M:Windows.Win32.PInvoke.GetDC(Windows.Win32.Foundation.HWND)">
            <summary>The GetDC function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire screen.</summary>
            <param name="hWnd">A handle to the window whose DC is to be retrieved. If this value is <b>NULL</b>, <b>GetDC</b> retrieves the DC for the entire screen.</param>
            <returns>
            <para>If the function succeeds, the return value is a handle to the DC for the specified window's client area. If the function fails, the return value is <b>NULL</b>.</para>
            </returns>
            <remarks>
            <para>The <b>GetDC</b> function retrieves a common, class, or private DC depending on the class style of the specified window. For class and private DCs, <b>GetDC</b> leaves the previously assigned attributes unchanged. However, for common DCs, <b>GetDC</b> assigns default attributes to the DC each time it is retrieved. For example, the default font is System, which is a bitmap font. Because of this, the handle to a common DC returned by <b>GetDC</b> does not tell you what font, color, or brush was used when the window was drawn. To determine the font, call <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-gettextfacea">GetTextFace</a>. Note that the handle to the DC can only be used by a single thread at any one time. After painting with a common DC, the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-releasedc">ReleaseDC</a> function must be called to release the DC. Class and private DCs do not have to be released. <b>ReleaseDC</b> must be called from the same thread that called <b>GetDC</b>. The number of DCs is limited only by available memory.</para>
            <para><see href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-getdc#">Read more on docs.microsoft.com</see>.</para>
            </remarks>
        </member>
    </members>
</doc>
