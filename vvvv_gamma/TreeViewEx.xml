<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TreeViewEx</name>
    </assembly>
    <members>
        <member name="M:System.Windows.Automation.Peers.TreeViewExAutomationPeer.CreateItemAutomationPeer(System.Object)">
            <summary>
            When overridden in a derived class, creates a new instance of the <see cref="T:System.Windows.Automation.Peers.ItemAutomationPeer"/> for a data item in the <see cref="P:System.Windows.Controls.ItemsControl.Items"/> collection of this <see cref="T:System.Windows.Controls.ItemsControl"/>.
            </summary>
            <param name="item">
            The data item that is associated with this <see cref="T:System.Windows.Automation.Peers.ItemAutomationPeer"/>.
            </param>
            <returns>
            The new <see cref="T:System.Windows.Automation.Peers.ItemAutomationPeer"/> created.
            </returns>
        </member>
        <member name="M:System.Windows.Controls.DoubleUtil.AreClose(System.Double,System.Double)">
            <summary>
            AreClose - Returns whether or not two doubles are "close".  That is, whether or
            not they are within epsilon of each other.  Note that this epsilon is proportional
            to the numbers themselves to that AreClose survives scalar multiplication.
            There are plenty of ways for this to return false even for numbers which
            are theoretically identical, so no code calling this should fail to work if this
            returns false.  This is important enough to repeat:
            NB: NO CODE CALLING THIS FUNCTION SHOULD DEPEND ON ACCURATE RESULTS - this should be
            used for optimizations *only*.
            </summary>
            <returns>
            bool - the result of the AreClose comparision.
            </returns>
            <param name="value1"> The first double to compare.</param>
            <param name="value2"> The second double to compare.</param>
        </member>
        <member name="M:System.Windows.Controls.DoubleUtil.LessThan(System.Double,System.Double)">
            <summary>
            LessThan - Returns whether or not the first double is less than the second double.
            That is, whether or not the first is strictly less than *and* not within epsilon of
            the other number.  Note that this epsilon is proportional to the numbers themselves
            to that AreClose survives scalar multiplication.  Note,
            There are plenty of ways for this to return false even for numbers which
            are theoretically identical, so no code calling this should fail to work if this
            returns false.  This is important enough to repeat:
            NB: NO CODE CALLING THIS FUNCTION SHOULD DEPEND ON ACCURATE RESULTS - this should be
            used for optimizations *only*.
            </summary>
            <returns>
            bool - the result of the LessThan comparision.
            </returns>
            <param name="value1"> The first double to compare. </param>
            <param name="value2"> The second double to compare.</param>
        </member>
        <member name="M:System.Windows.Controls.DoubleUtil.GreaterThan(System.Double,System.Double)">
            <summary>
            GreaterThan - Returns whether or not the first double is greater than the second double.
            That is, whether or not the first is strictly greater than *and* not within epsilon of
            the other number.  Note that this epsilon is proportional to the numbers themselves
            to that AreClose survives scalar multiplication.  Note,
            There are plenty of ways for this to return false even for numbers which
            are theoretically identical, so no code calling this should fail to work if this
            returns false.  This is important enough to repeat:
            NB: NO CODE CALLING THIS FUNCTION SHOULD DEPEND ON ACCURATE RESULTS - this should be
            used for optimizations *only*.
            </summary>
            <returns>
            bool - the result of the GreaterThan comparision.
            </returns>
            <param name="value1"> The first double to compare. </param>
            <param name="value2"> The second double to compare.</param>
        </member>
        <member name="M:System.Windows.Controls.DoubleUtil.LessThanOrClose(System.Double,System.Double)">
            <summary>
            LessThanOrClose - Returns whether or not the first double is less than or close to
            the second double.  That is, whether or not the first is strictly less than or within
            epsilon of the other number.  Note that this epsilon is proportional to the numbers
            themselves to that AreClose survives scalar multiplication.  Note,
            There are plenty of ways for this to return false even for numbers which
            are theoretically identical, so no code calling this should fail to work if this
            returns false.  This is important enough to repeat:
            NB: NO CODE CALLING THIS FUNCTION SHOULD DEPEND ON ACCURATE RESULTS - this should be
            used for optimizations *only*.
            </summary>
            <returns>
            bool - the result of the LessThanOrClose comparision.
            </returns>
            <param name="value1"> The first double to compare. </param>
            <param name="value2"> The second double to compare.</param>
        </member>
        <member name="M:System.Windows.Controls.DoubleUtil.GreaterThanOrClose(System.Double,System.Double)">
            <summary>
            GreaterThanOrClose - Returns whether or not the first double is greater than or close to
            the second double.  That is, whether or not the first is strictly greater than or within
            epsilon of the other number.  Note that this epsilon is proportional to the numbers
            themselves to that AreClose survives scalar multiplication.  Note,
            There are plenty of ways for this to return false even for numbers which
            are theoretically identical, so no code calling this should fail to work if this
            returns false.  This is important enough to repeat:
            NB: NO CODE CALLING THIS FUNCTION SHOULD DEPEND ON ACCURATE RESULTS - this should be
            used for optimizations *only*.
            </summary>
            <returns>
            bool - the result of the GreaterThanOrClose comparision.
            </returns>
            <param name="value1"> The first double to compare.</param>
            <param name="value2"> The second double to compare.</param>
        </member>
        <member name="M:System.Windows.Controls.DoubleUtil.IsOne(System.Double)">
            <summary>
            IsOne - Returns whether or not the double is "close" to 1.  Same as AreClose(double, 1),
            but this is faster.
            </summary>
            <returns>
            bool - the result of the AreClose comparision.
            </returns>
            <param name="value"> The double to compare to 1. </param>
        </member>
        <member name="M:System.Windows.Controls.DoubleUtil.IsZero(System.Double)">
            <summary>
            IsZero - Returns whether or not the double is "close" to 0.  Same as AreClose(double, 0),
            but this is faster.
            </summary>
            <returns>
            bool - the result of the AreClose comparision.
            </returns>
            <param name="value"> The double to compare to 0.</param>
        </member>
        <member name="M:System.Windows.Controls.DoubleUtil.AreClose(System.Windows.Point,System.Windows.Point)">
            <summary>
            Compares two points for fuzzy equality.  This function
            helps compensate for the fact that double values can
            acquire error when operated upon
            </summary>
            <param name="point1">The first point to compare</param>
            <param name="point2">The second point to compare</param>
            <returns>Whether or not the two points are equal</returns>
        </member>
        <member name="M:System.Windows.Controls.DoubleUtil.AreClose(System.Windows.Size,System.Windows.Size)">
            <summary>
            Compares two Size instances for fuzzy equality.  This function
            helps compensate for the fact that double values can
            acquire error when operated upon
            </summary>
            <param name="size1">The first size to compare</param>
            <param name="size2">The second size to compare</param>
            <returns>Whether or not the two Size instances are equal</returns>
        </member>
        <member name="M:System.Windows.Controls.DoubleUtil.AreClose(System.Windows.Vector,System.Windows.Vector)">
            <summary>
            Compares two Vector instances for fuzzy equality.  This function
            helps compensate for the fact that double values can
            acquire error when operated upon
            </summary>
            <param name="vector1">The first Vector to compare</param>
            <param name="vector2">The second Vector to compare</param>
            <returns>Whether or not the two Vector instances are equal</returns>
        </member>
        <member name="M:System.Windows.Controls.DoubleUtil.AreClose(System.Windows.Rect,System.Windows.Rect)">
            <summary>
            Compares two rectangles for fuzzy equality.  This function
            helps compensate for the fact that double values can
            acquire error when operated upon
            </summary>
            <param name="rect1">The first rectangle to compare</param>
            <param name="rect2">The second rectangle to compare</param>
            <returns>Whether or not the two rectangles are equal</returns>
        </member>
        <member name="M:System.Windows.Controls.DoubleUtil.IsBetweenZeroAndOne(System.Double)">
             <summary>
            
             </summary>
             <param name="val" />
             <returns></returns>
        </member>
        <member name="M:System.Windows.Controls.DoubleUtil.DoubleToInt(System.Double)">
             <summary>
            
             </summary>
             <param name="val" />
             <returns></returns>
        </member>
        <member name="M:System.Windows.Controls.DoubleUtil.RectHasNaN(System.Windows.Rect)">
            <summary>
            rectHasNaN - this returns true if this rect has X, Y , Height or Width as NaN.
            </summary>
            <param name="r">The rectangle to test</param>
            <returns>returns whether the Rect has NaN</returns>
        </member>
        <member name="M:System.Windows.Controls.DragNDrop.DragNDropController.TryScroll(System.Windows.Point)">
            <summary>
            Scrolls if mouse is pressed and over scroll border. 
            </summary>
            <param name="position">Mouse position relative to treeView control.</param>
            <returns>Returns true if over scroll border, otherwise false.</returns>
        </member>
        <member name="T:System.Windows.Controls.EditTextBox">
            <summary>
            Text box which focuses itself on load and selects all text in it.
            </summary>
        </member>
        <member name="T:System.Windows.Controls.FocusHelper">
            <summary>
            Helper methods to focus.
            </summary>
        </member>
        <member name="T:System.Windows.Controls.InputSubscriberBase">
            <summary>
            Base for a class, which wants to be provided with mouse events.
            </summary>
        </member>
        <member name="T:System.Windows.Controls.ISelectionStrategy">
            <summary>
            TODO: Update summary.
            </summary>
        </member>
        <member name="F:System.Windows.Controls.PropertyChangedNotifier.ValueProperty">
            <summary>
            Identifies the <see cref="P:System.Windows.Controls.PropertyChangedNotifier.Value"/> dependency property
            </summary>
        </member>
        <member name="P:System.Windows.Controls.PropertyChangedNotifier.Value">
            <summary>
            Returns/sets the value of the property
            </summary>
            <seealso cref="F:System.Windows.Controls.PropertyChangedNotifier.ValueProperty"/>
        </member>
        <member name="T:System.Windows.Controls.SelectionMultiple">
            <summary>
            Logic for the multiple selection
            </summary>
        </member>
        <member name="T:System.Windows.Controls.SelectionSingle">
            <summary>
            TODO: Update summary.
            </summary>
        </member>
        <member name="M:System.Windows.Controls.TreeViewElementFinder.FindFirst(System.Windows.Controls.TreeViewEx,System.Boolean)">
            <summary>
            Returns the first item. If tree is virtualized, it is the first realized item.
            </summary>
            <param name="treeView">The tree.</param>
            <param name="visibleOnly"></param>
            <returns>Returns a TreeViewExItem.</returns>
        </member>
        <member name="M:System.Windows.Controls.TreeViewElementFinder.FindLast(System.Windows.Controls.TreeViewEx,System.Boolean)">
            <summary>
            Returns the last item. If tree is virtualized, it is the last realized item.
            </summary>
            <param name="treeView">The tree.</param>
            <param name="visibleOnly"></param>
            <returns>Returns a TreeViewExItem.</returns>
        </member>
        <member name="M:System.Windows.Controls.TreeViewElementFinder.FindAll(System.Windows.Controls.TreeViewEx,System.Boolean)">
            <summary>
            Returns all items in tree recursively. If virtualization is enabled, only realized items are returned.
            </summary>
            <param name="treeView">The tree.</param>
            <param name="visibleOnly">True if only visible items should be returned.</param>
            <returns>Returns an enumerable of items.</returns>
        </member>
        <member name="P:System.Windows.Controls.TreeViewEx.LastSelectedItem">
            <summary>
              Gets the last selected item.
            </summary>
        </member>
        <member name="P:System.Windows.Controls.TreeViewEx.SelectedItems">
            <summary>
              Gets or sets a list of selected items and can be bound to another list. If the source list implements <see
               cref="T:System.ComponentModel.INotifyPropertyChanged" /> the changes are automatically taken over.
            </summary>
        </member>
        <member name="M:System.Windows.Controls.TreeViewEx.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)">
            <summary>
            Send down the IsVirtualizing property if it's set on this element.
            </summary>
            <param name="element" />
            <param name="item" />
        </member>
        <member name="M:System.Windows.Controls.TreeViewEx.OnItemsChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
                This method is invoked when the Items property changes.
            </summary>
        </member>
        <member name="T:System.Windows.Controls.TreeViewExItem">
            <summary>
            An item of the TreeViewEx.
            </summary>
        </member>
        <member name="M:System.Windows.Controls.TreeViewExItem.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)">
            <summary>
            Send down the IsVirtualizing property if it's set on this element.
            </summary>
            <param name="element"/>
            <param name="item"/>
        </member>
        <member name="M:System.Windows.Controls.TreeViewExItem.OnItemsChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
                This method is invoked when the Items property changes.
            </summary>
        </member>
        <member name="M:System.Windows.Controls.TreeViewExItem.IsItemItsOwnContainerOverride(System.Object)">
            <summary>
                Returns true if the item is or should be its own container.
            </summary>
            <param name="item">The item to test.</param>
            <returns>true if its type matches the container type.</returns>
        </member>
        <member name="M:System.Windows.Controls.TreeViewExItem.GetContainerForItemOverride">
            <summary>
                Create or identify the element used to display the given item.
            </summary>
            <returns>The container.</returns>
        </member>
        <member name="M:System.Windows.Controls.VirtualizingTreePanel.MeasureOverride(System.Windows.Size)">
            <summary>
            Measure the children
            </summary>
            <param name="availableSize">Size available</param>
            <returns>Size desired</returns>
        </member>
        <member name="M:System.Windows.Controls.VirtualizingTreePanel.ArrangeOverride(System.Windows.Size)">
            <summary>
            Arrange the children
            </summary>
            <param name="finalSize">Size available</param>
            <returns>Size used</returns>
        </member>
        <member name="M:System.Windows.Controls.VirtualizingTreePanel.CleanUpItems(System.Int32,System.Int32)">
            <summary>
            Revirtualize items that are no longer visible
            </summary>
            <param name="minDesiredGenerated">first item index that should be visible</param>
            <param name="maxDesiredGenerated">last item index that should be visible</param>
        </member>
        <member name="M:System.Windows.Controls.VirtualizingTreePanel.OnItemsChanged(System.Object,System.Windows.Controls.Primitives.ItemsChangedEventArgs)">
            <summary>
            When items are removed, remove the corresponding UI if necessary
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="M:System.Windows.Controls.VirtualizingTreePanel.GetCachedOrEstimatedHeight(System.Windows.Controls.TreeViewEx,System.Int32)">
            <summary>
            Returns the size of the container for a given item.  The size can come from the container, a lookup, or a guess depending
            on the virtualization state of the item.
            </summary>
            <returns>The cached or estimated size.</returns>
            <remarks>This estimation looks if the given index is cached. If not it returns the maximum height of the cached
            containers. If no container is cached, returns zero. 
            One case it fails is, if all cached items are bigger
            than the estimated items. This leads to jumping scrollbars. The effect is not that bad, if many items will be visualized.</remarks>
        </member>
        <member name="T:System.Windows.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:System.Windows.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:System.Windows.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
    </members>
</doc>
