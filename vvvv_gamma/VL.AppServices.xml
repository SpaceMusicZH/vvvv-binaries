<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VL.AppServices</name>
    </assembly>
    <members>
        <member name="M:VL.AppServices.AppHostBase.SetScope(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Boolean)">
            <summary>
            Sets the scope of the host. Refreshes type regsitry and adaptive lookup tables.
            </summary>
        </member>
        <member name="M:VL.AppServices.CompilerServices.AdaptiveImplementationProvider.CSharpName(System.Type)">
            <summary>
            Get full type name with full namespace names
            </summary>
            <param name="type">
            The type to get the C# name for (may be a generic type or a nullable type).
            </param>
            <returns>
            Full type name, fully qualified namespaces
            </returns>
        </member>
        <member name="P:VL.AppServices.CompilerServices.AdaptiveImplementationsAttribute.TargetType">
            <summary>
            The struct which carries the implementations.
            </summary>
        </member>
        <member name="P:VL.AppServices.CompilerServices.AdaptiveNodeLookupAttribute.TargetType">
            <summary>
            The class which holds all adaptive instantiations and its implementations.
            </summary>
        </member>
        <member name="P:VL.AppServices.CompilerServices.CustomRegion.CustomRegionAttribute.NodeOrRegionChoice">
            <summary>
            Allows to customize whether the region can also be created as a node.
            </summary>
        </member>
        <member name="P:VL.AppServices.CompilerServices.CustomRegion.CustomRegionAttribute.SupportedBorderControlPoints">
            <summary>
            What control points the region shall support.
            </summary>
        </member>
        <member name="P:VL.AppServices.CompilerServices.CustomRegion.CustomRegionAttribute.TypeConstraint">
            <summary>
            The type constraint to apply on the control points. 
            In case of splicers the system will try to align the inner type (e.g. float) with the inner most argument (and also right most) of the outer (e.g. Spread{float} or Dictionary{string, float}).
            </summary>
        </member>
        <member name="P:VL.AppServices.CompilerServices.CustomRegion.CustomRegionAttribute.NodeOrRegionChoice_CompileTime">
            <summary>
            Allows to customize whether the region can also be created as a node.
            </summary>
        </member>
        <member name="P:VL.AppServices.CompilerServices.CustomRegion.CustomRegionAttribute.SupportedBorderControlPointsSpecified_CompileTime">
            <summary>
            What control points the region shall support.
            </summary>
        </member>
        <member name="P:VL.AppServices.CompilerServices.ElementAttribute.TracingId">
            <summary>
            The element id which lead to this CLR symbol.
            </summary>
        </member>
        <member name="P:VL.AppServices.CompilerServices.ElementAttribute.DocumentId">
            <summary>
            The document id.
            </summary>
        </member>
        <member name="P:VL.AppServices.CompilerServices.ElementAttribute.PersistentId">
            <summary>
            The persistent element id which lead to this CLR symbol.
            </summary>
        </member>
        <member name="P:VL.AppServices.CompilerServices.ElementAttribute.IsAutoGenerated">
            <summary>
            Whether or not the element was auto generated by the compiler.
            </summary>
        </member>
        <member name="P:VL.AppServices.CompilerServices.ElementAttribute.IsManaged">
            <summary>
            Whether or not the field will be disposed when it goes out of scope during a hotswap.
            </summary>
        </member>
        <member name="P:VL.AppServices.CompilerServices.ElementAttribute.Name">
            <summary>
            The name of the element. This is set in case the compiler generated name differs from the one set in VL.
            </summary>
        </member>
        <member name="P:VL.AppServices.CompilerServices.ElementAttribute.NodeName">
            <summary>
            The name of the node description which lead to this element. Used by dynamic nodes during hot swap.
            </summary>
        </member>
        <member name="P:VL.AppServices.CompilerServices.ElementAttribute.NodeCategory">
            <summary>
            The category of the node description which lead to this element. Used by dynamic nodes during hot swap.
            </summary>
        </member>
        <member name="T:VL.AppServices.CompilerServices.Intrinsics.CacheManager`2">
            <summary>
            var manager = this.manager;
            var inputs = (a, b, c);
            if (force || manager.InputsChanged(inputs))
            {
              var state = manager.State;
              if (state is null)
                state = CREATE
              UPDATE
              var outputs = (x, y, z);
              manager = manager.Update(inputs, disposeOutputs, state, outputs);
            }
            else
            {
              manager = manager.Update(inputs, disposeOutputs);
            }
            </summary>
            <typeparam name="TInputs"></typeparam>
            <typeparam name="TOutputs"></typeparam>
        </member>
        <member name="T:VL.AppServices.CompilerServices.SerializedDefaultValueAttribute">
            <summary>
            Attached to parameters to encode the default value.
            </summary>
        </member>
        <member name="M:VL.AppServices.CompilationHelper.TryDisguise``1(VL.AppServices.Hotswap.ITrackedVLObject)">
            <summary>
            COMPILER ONLY. This method should only get called for explicit interface implementations. 
            We don't check for outdated in some cases, as this is done inside the to be called method already
            </summary>
        </member>
        <member name="M:VL.AppServices.CompilationHelper.TryDisguiseInputMaybeAnything``1(System.Object)">
            <summary>
            You can call this when you are not sure if you want to trigger a restore and let the user decide.
            This also makes sure that users don't run into follow up issues of an incomplete hotswap, like null pointer exceptions. 
            Even when the user patched everything correctly.
            The alternative is the very cheap Self operation, which is also will prevent the user from nightmare debugging wher a restart solves the issue.
            </summary>
        </member>
        <member name="M:VL.AppServices.CompilationHelper.TryDisguiseInputMaybeAnything``1(VL.AppServices.Hotswap.ITrackedVLObject)">
            <summary>
            You can call this when you are not sure if you want to trigger a restore and let the user decide.
            This also makes sure that users don't run into follow up issues of an incomplete hotswap, like null pointer exceptions. 
            Even when the user patched everything correctly.
            The alternative is the very cheap Self operation, which is also will prevent the user from nightmare debugging wher a restart solves the issue.
            </summary>
        </member>
        <member name="M:VL.AppServices.CompilationHelper.Self(System.Object)">
            <summary>
            This will give you a hand onto a restore object if there is any. 
            This also makes sure that users don't run into follow up issues of an incomplete hotswap. 
            Restarts before the user can when something doesn't match anymore.
            </summary>
        </member>
        <member name="M:VL.AppServices.CompilationHelper.Self(VL.AppServices.Hotswap.ITrackedVLObject)">
            <summary>
            This will give you a hand onto a restore object if there is any. 
            This also makes sure that users don't run into follow up issues of an incomplete hotswap. 
            </summary>
        </member>
        <member name="M:VL.AppServices.CompilationHelper.ShieldedDisposeCatchingAllExceptions(System.Object)">
            <summary>
            Turns off restoring fields and any restore related exceptions.
            Also swallows all other exceptions. We use this in order to shut down the old object as thoroughly as possible.
            Used in different places of the hotswap system. Used by HDE to shutdown tooltips. Used in Runtime to stop ignorant.
            </summary>
        </member>
        <member name="M:VL.AppServices.CompilationHelper.ShieldedDisposeForManagedFields(System.Object)">
            <summary>
            Shielding Dispose call from hotswap algorithm. 
            Used in target code making sure that normal exceptions do get reported.
            </summary>
        </member>
        <member name="M:VL.AppServices.CompilationHelper.MakeGenericAdaptiveType(System.Type,System.Type[])">
            <summary>
            Same as MakeGenericType but taking adaptive node parameters into account.
            </summary>
            <param name="type">The generic type defintion. Can be the public type (Particle&lt;T&gt;) or the private type (Particle&lt;T, AdC&gt;)</param>
            <param name="arguments">The generic arguments.</param>
            <returns>The fully instantiated private type for e.g. Particle&lt;float, __SOME_STRUCT__&gt;</returns>
            <exception cref="T:System.InvalidOperationException">If no adaptive implementation struct was found.</exception>
            <remarks>
            This method currently fails if the provided arguments lead to adaptive instantiations which haven't been seen by the compiler.
            We therefor keep the method internal for now.
            </remarks>
        </member>
        <member name="T:VL.AppServices.ExportedAppHost">
            <summary>
            Encapsulates all the platform independent logic to run a VL app.
            </summary>
        </member>
        <member name="M:VL.AppServices.Hotswap.SwappableVLObject`1.__Restore``1">
            <summary>
            This gets called from every taget code method with TStateClass being the State object of the program
            </summary>
        </member>
        <member name="P:VL.AppServices.Hotswap.TypeTracker.LatestTypeDefinition">
            <summary>
            Particle'1
            </summary>
        </member>
        <member name="P:VL.AppServices.Hotswap.TypeTracker.LatestProgramDefinition">
            <summary>
            ParticleProgram'2 (AdC is the second)
            </summary>
        </member>
        <member name="F:VL.AppServices.Hotswap.VLObjectProgram.Instantiations">
            <summary>
            Keeps track of all instantiations which occur during runtime.
            </summary>
        </member>
        <member name="T:VL.AppServices.Logging.ConsoleErrorListener">
            <summary>
            Used to redirect the <see cref="P:System.Console.Error"/> stream to an <see cref="T:Microsoft.Extensions.Logging.ILogger"/>.
            </summary>
        </member>
        <member name="T:VL.AppServices.Logging.ConsoleOutputListener">
            <summary>
            Used to redirect the <see cref="P:System.Console.Out"/> stream to an <see cref="T:Microsoft.Extensions.Logging.ILogger"/>.
            </summary>
        </member>
        <member name="T:VL.AppServices.Logging.LoggerTraceListener">
            <summary>
            Used to pipe <see cref="T:System.Diagnostics.Trace"/> and <see cref="T:System.Diagnostics.Debug"/> message to an <see cref="T:Microsoft.Extensions.Logging.ILogger"/>.
            </summary>
        </member>
        <member name="M:VL.AppServices.Serialization.SerializationContextInternal.#ctor(VL.Core.AppHost,VL.Core.NodeContext,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Creates a new serialization context.
            </summary>
            <param name="appHost">The app host.</param>
            <param name="nodeContext">The node context.</param>
            <param name="throwOnError">Whether or not serialization errors should lead to an exception.</param>
            <param name="includeDefaults">If true default values will also be serialized.</param>
            <param name="pathsAreRelativeToDocument">If true paths are serialized relative to the document path (given by the node context)</param>
            <param name="version">The version of the serialization format.</param>
        </member>
        <member name="P:VL.AppServices.Serialization.SerializationContextInternal.Version">
            <summary>
            The version of the serialization format.
            </summary>
        </member>
        <member name="P:VL.AppServices.Serialization.SerializationContextInternal.Factory">
            <summary>
            The VL factory.
            </summary>
        </member>
        <member name="P:VL.AppServices.Serialization.SerializationContextInternal.ThrowOnError">
            <summary>
            Whether or not serialization error should lead to an exception
            </summary>
        </member>
        <member name="P:VL.AppServices.Serialization.SerializationContextInternal.IncludeDefaults">
            <summary>
            Whether or not default values will also be serialized.
            </summary>
        </member>
        <member name="P:VL.AppServices.Serialization.SerializationContextInternal.PathsAreRelativeToDocument">
            <summary>
            Whether or not paths should be relative to the current document (defined by the node context) or to the application entry point.
            </summary>
        </member>
        <member name="P:VL.AppServices.Serialization.SerializationContextInternal.Errors">
            <summary>
            The accumulated error messages.
            </summary>
        </member>
        <member name="P:VL.AppServices.Serialization.SerializationContextInternal.Services">
            <summary>
            The service provider.
            </summary>
        </member>
        <member name="F:VL.AppServices.Serialization.SerializationContextInternal.NodeContext">
            <summary>
            The node context of the object currently being serialized. Used to resolve paths.
            </summary>
        </member>
        <member name="P:VL.AppServices.Serialization.SerializationContextInternal.TypeRegistry">
            <summary>
            The type registry used to map .NET types to VL types.
            </summary>
        </member>
        <member name="M:VL.AppServices.Serialization.SerializationContextInternal.ReportError(System.String)">
            <summary>
            Reports an error. Will throw a <see cref="T:VL.Core.SerializationException"/> in case <see cref="P:VL.AppServices.Serialization.SerializationContextInternal.ThrowOnError"/> is enabled.
            </summary>
            <param name="message">The error message to report.</param>
        </member>
        <member name="M:VL.AppServices.Serialization.SerializationContextInternal.GetTagName(System.Type)">
            <summary>
            Returns the name of the type without any generic type parameter suffixes and replaces [] with Array.
            </summary>
        </member>
        <member name="F:VL.AppServices.Serialization.SerializationServiceImpl.ReflectionNamespace">
            <summary>
            The reflection namespace.
            </summary>
        </member>
        <member name="F:VL.AppServices.Serialization.SerializationServiceImpl.TypeAttributeName">
            <summary>
            The name of the type attribute.
            </summary>
        </member>
        <member name="F:VL.AppServices.Serialization.SerializationServiceImpl.VersionAttributeName">
            <summary>
            The name of the version attribute.
            </summary>
        </member>
        <member name="M:VL.AppServices.Serialization.SerializationServiceImpl.RegisterSerializers(VL.Core.IVLFactory)">
            <summary>
            Registers all the default serializers in the factory.
            </summary>
            <param name="factory">The factory to register in.</param>
        </member>
        <member name="M:VL.AppServices.Serialization.SerializationServiceImpl.GetSerializer(VL.Core.IVLFactory,System.Type)">
            <summary>
            Gets a serializer for the given type.
            </summary>
            <param name="factory">The factory to fetch the serializer from.</param>
            <param name="forType">The type for which a serializer has to be fetched.</param>
            <returns>The serializer or null in case no serializer is registered for that type.</returns>
        </member>
        <member name="T:VL.AppServices.Serialization.Serializer">
            <summary>
            The non-generic serializer class.
            </summary>
        </member>
        <member name="M:VL.AppServices.Serialization.Serializer.Serialize(VL.Core.SerializationContext,System.Object)">
            <summary>
            Serializes the given value to a string, object[] or XElement.
            </summary>
            <param name="context">The factory to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <returns>The serialized value as <see cref="T:System.String"/>, <see cref="T:Object[]"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.AppServices.Serialization.Serializer.Deserialize(VL.Core.SerializationContext,System.Object,System.Type)">
            <summary>
            Deserializes the given content.
            </summary>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content (string, object[] or XElement) to deserialize.</param>
            <param name="type">The type of the deserialized value.</param>
            <returns>The deserialized value or the default value in case deserialization failed.</returns>
        </member>
        <member name="T:VL.AppServices.Serialization.UngenericDelegatingSerializer`1">
            <summary>
            Bridge to user implemented generic serializer interface.
            </summary>
            <typeparam name="T">The type of the value to serialize.</typeparam>
        </member>
        <member name="T:VL.AppServices.Serialization.CollectionSerializer`2">
            <summary>
            The abstract base class to use when writing a VL serializer for a collection type.
            </summary>
            <typeparam name="TElement">The element type of the collection.</typeparam>
            <typeparam name="TCollection">The type of the collection.</typeparam>
        </member>
        <member name="T:VL.Core.CompilerServices.AdaptiveTypeAttribute">
            <summary>
            For example used on Particle&lt;T&gt; pointing to Particle&lt;T, AdC&gt;
            </summary>
        </member>
        <member name="T:VL.Core.CompilerServices.PrivateImplAttribute">
            <summary>
            Gets attached to private VL object implementations.
            </summary>
        </member>
        <member name="T:VL.Core.EventBridge">
            <summary>
            Contains helper functions to turn .NET events into observables.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern(System.Type,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given type and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern(System.Object,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given target object and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern``1(System.Type,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given type and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern``1(System.Object,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given target object and event name.
            </summary>
        </member>
        <member name="T:VL.Core.PreciseMainLoopTimer">
            <summary>
            Timer using the busy wait method on a new thread, extremely accurate but uses a bit of CPU.
            </summary>
        </member>
        <member name="M:VL.Core.PreciseMainLoopTimer.#ctor">
            <summary>
            Initializes a new instance of the Timer class.
            </summary>
        </member>
        <member name="P:VL.Core.PreciseMainLoopTimer.Interval">
            <summary>
            Gets or sets the time between Tick events.
            </summary>
        </member>
        <member name="P:VL.Core.PreciseMainLoopTimer.Mode">
            <summary>
            Gets or sets the timer mode.
            </summary>
        </member>
        <member name="P:VL.Core.PreciseMainLoopTimer.Increment">
            <summary>
            Gets or sets the time increment. Used when <see cref="P:VL.Core.PreciseMainLoopTimer.IsIncremental"/> is set to true.
            </summary>
        </member>
        <member name="P:VL.Core.PreciseMainLoopTimer.IsRunning">
            <summary>
            Gets a value indicating whether the Timer is running.
            </summary>
        </member>
        <member name="E:VL.Core.PreciseMainLoopTimer.Tick">
            <summary>
            Occurs when the Timer has completed one interval.
            </summary>
        </member>
        <member name="M:VL.Core.PreciseMainLoopTimer.Start">
            <summary>
            Starts the timer.
            </summary>
        </member>
        <member name="M:VL.Core.PreciseMainLoopTimer.Stop">
            <summary>
            Stops timer.
            </summary>
        </member>
        <member name="M:VL.Core.PreciseMainLoopTimer.Dispose">
            <summary>
            Frees timer resources.
            </summary>
        </member>
        <member name="T:VL.Core.WindowsTimerUtils">
            <summary>
            Description of WinApiCalls.
            </summary>
        </member>
        <member name="F:VL.Core.PatchedObject.WithMethodName">
            <summary>
            The name of the auto generated With method used to update the fields.
            </summary>
        </member>
        <member name="M:VL.Core.PatchHandle.#ctor(System.UInt32)">
            <summary>
            We only know of the patch. No node path, no object identity available
            </summary>
        </member>
        <member name="M:VL.Core.PatchHandle.#ctor(VL.Core.NodePath)">
            <summary>
            That's already quite nice! We know the node path, but no object identity available
            </summary>
        </member>
    </members>
</doc>
