/**************************
***** Compiler Parameters *****
***************************
@P EffectName: ComputeFXEffect
@P   - ComputeEffectShader.ThreadNumbers: X:1 Y:1 Z:1
@P EffectNodeBase.EffectNodeBaseShader: mixin DCGenerateTriangles_ComputeFX [{SDF = Float3ToFloat}]
@P SDF: Float3ToFloat
***************************
****  ConstantBuffers  ****
***************************
cbuffer Globals [Size: 48]
@C    NumberOfVoxels_id17 => SDFVoxelVolume.NumberOfVoxels
@C    VoxelSpacing_id18 => SDFVoxelVolume.VoxelSpacing
@C    VolumeOffset_id19 => SDFVoxelVolume.VolumeOffset
@C    cellStride_id22 => DualContouringUtils.cellStride
@C    schmitzParticleIterations_id23 => DualContouringUtils.schmitzParticleIterations
@C    schmitzParticleStepSize_id24 => DualContouringUtils.schmitzParticleStepSize
@C    UseSDFNormal_id25 => DualContouringUtils.UseSDFNormal
***************************
******  Resources    ******
***************************
@R    VoxelVolume_id16 => SDFVoxelVolume.VoxelVolume [Stage: Compute, Slot: (0-0)]
@R    cellVertexInfoLookupTable_id26 => DualContouringUtils.cellVertexInfoLookupTable [Stage: Compute, Slot: (1-1)]
@R    generatedTriangles_id30 => DualContouringUtils.generatedTriangles [Stage: Compute, Slot: (2-2)]
@R    Globals => Globals [Stage: Compute, Slot: (0-0)]
***************************
*****     Sources     *****
***************************
@S    ComputeShaderBase => 8f045851eaa4513eb38a704d53889e6d
@S    DCGenerateTriangles_ComputeFX => 85b8dcc3ffd79909b3a076231b0ff166
@S    DualContouringUtils => 6983a768905494dba6ecf7a940211aaf
@S    SDFInput => a9a2d11c443f5dcd90f5f02aeaa8a31d
@S    Float3ToFloat => 2f0e51a8298c61a56eadba3a099d3a38
@S    SDFCell => 6534f6064f13ddc49aee1189d082646f
@S    SDFVertex => a55fb6c0cb5db6eac29bd614045e195f
@S    SDFVoxelVolume => bc75ddec3ed07697b2259473a518c873
@S    SDFVoxel => d74a04a0d37ae8f2dc735e623d43aecc
***************************
*****     Stages      *****
***************************
@G    Compute => 0cbe8bff90cecca5a39a0aeb030f3355
//
// Generated by Microsoft (R) HLSL Shader Compiler 10.1
//
//
// Buffer Definitions: 
//
// cbuffer Globals
// {
//
//   int3 NumberOfVoxels_id17;          // Offset:    0 Size:    12
//   float VoxelSpacing_id18;           // Offset:   12 Size:     4 [unused]
//   float3 VolumeOffset_id19;          // Offset:   16 Size:    12 [unused]
//   uint cellStride_id22;              // Offset:   28 Size:     4
//      = 0x00000001 
//   uint schmitzParticleIterations_id23;// Offset:   32 Size:     4 [unused]
//      = 0x00000014 
//   float schmitzParticleStepSize_id24;// Offset:   36 Size:     4 [unused]
//      = 0x3e4ccccd 
//   bool UseSDFNormal_id25;            // Offset:   40 Size:     4 [unused]
//
// }
//
// Resource bind info for VoxelVolume_id16
// {
//
//   struct Voxel
//   {
//       
//       float4 valueAndGradient;       // Offset:    0
//
//   } $Element;                        // Offset:    0 Size:    16
//
// }
//
// Resource bind info for cellVertexInfoLookupTable_id26
// {
//
//   struct CellVertexInfo
//   {
//       
//       uint index;                    // Offset:    0
//
//   } $Element;                        // Offset:    0 Size:     4
//
// }
//
// Resource bind info for generatedTriangles_id30
// {
//
//   uint3 $Element;                    // Offset:    0 Size:    12
//
// }
//
//
// Resource Bindings:
//
// Name                                 Type  Format         Dim      HLSL Bind  Count
// ------------------------------ ---------- ------- ----------- -------------- ------
// VoxelVolume_id16                      UAV  struct         r/w             u0      1 
// cellVertexInfoLookupTable_id26        UAV  struct     r/w+cnt             u1      1 
// generatedTriangles_id30               UAV  struct         r/w             u2      1 
// Globals                           cbuffer      NA          NA            cb0      1 
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// no Input
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// no Output
cs_5_0
dcl_globalFlags refactoringAllowed
dcl_immediateConstantBuffer { { 0, 3, 0, 0},
                              { 3, 7, 0, 0},
                              { 7, 4, 0, 0},
                              { 4, 0, 0, 0},
                              { 1, 2, 0, 0},
                              { 2, 6, 0, 0},
                              { 5, 6, 0, 0},
                              { 5, 1, 0, 0},
                              { 0, 1, 0, 0},
                              { 3, 2, 0, 0},
                              { 7, 6, 0, 0},
                              { 4, 5, 0, 0},
                              { 0, 0, 0, 0},
                              { 0, 1, 0, 0},
                              { 1, 1, 0, 0},
                              { 1, 0, 0, 0},
                              { 0, 0, 1, 0},
                              { 0, 1, 1, 0},
                              { 1, 1, 1, 0},
                              { 1, 0, 1, 0},
                              { 1, 2, 3, 0},
                              { 4, 5, 1, 0},
                              { 3, 7, 4, 0} }
dcl_constantbuffer CB0[2], immediateIndexed
dcl_uav_structured u0, 16
dcl_uav_structured_opc u1, 4
dcl_uav_structured u2, 12
dcl_input vThreadID.xyz
dcl_temps 6
dcl_indexableTemp x0[3], 4
dcl_thread_group 1, 1, 1
//
// Initial variable locations:
//   vThreadGroupID.x <- __input__.GroupId_id0.x; vThreadGroupID.y <- __input__.GroupId_id0.y; vThreadGroupID.z <- __input__.GroupId_id0.z; 
//   vThreadID.x <- __input__.DispatchThreadId_id1.x; vThreadID.y <- __input__.DispatchThreadId_id1.y; vThreadID.z <- __input__.DispatchThreadId_id1.z
//
#line 124 "C:\Program Files\vvvv\vvvv_gamma_2022.5.0-0485-g8f46e4a34a\log\shader_ComputeFXEffect_cd71130043a0a79d74d570f82a403339.hlsl"
iadd r0.xyz, cb0[0].xyzx, l(-3, -3, -3, 0)
ult r0.xyz, r0.xyzx, vThreadID.xyzx
or r0.x, r0.y, r0.x
or r0.x, r0.z, r0.x

#line 128
if_z r0.x

#line 69
  ieq r0.xyz, vThreadID.xyzx, l(0, 0, 0, 0)
  iadd r1.xyz, cb0[0].xyzx, l(-2, -2, -2, 0)
  ieq r2.xyz, r1.xyzx, vThreadID.xyzx
  or r0.xyz, r0.xyzx, r2.xyzx
  or r0.x, r0.y, r0.x
  or r0.x, r0.z, r0.x

#line 77
  iadd r0.yzw, vThreadID.xxyz, l(0, -1, -1, -1)
  udiv r0.yzw, null, r0.yyzw, cb0[1].wwww
  imad r0.yzw, r0.yyzw, cb0[1].wwww, l(0, 1, 1, 1)
  movc r0.xyz, r0.xxxx, vThreadID.xyzx, r0.yzwy  // r0.x <- coordinate.x; r0.y <- coordinate.y; r0.z <- coordinate.z

#line 78
  imul null, r0.w, cb0[0].y, cb0[0].x
  imad r0.x, r0.y, cb0[0].x, r0.x
  imad r0.x, r0.z, r0.w, r0.x  // r0.x <- <CalculateCellVertexInfoLookupTableIndex_id21 return value>

#line 128
  ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.x, l(0), u1.xxxx  // r0.x <- cellVertexInfo

#line 119
  mov r2.w, l(0)

#line 130
  mov r1.w, l(0)  // r1.w <- index
  loop 
    uge r3.x, r1.w, l(3)
    breakc_nz r3.x

#line 119
    ineg r3.x, r1.w
    ult r4.xy, r1.wwww, l(1, 2, 0, 0)
    and r4.z, r3.x, r4.y
    iadd r3.y, r1.w, l(-3)
    movc r4.w, r4.y, l(0), r3.y
    and r2.xyz, r4.xzwx, l(5, 6, 10, 0)
    or r2.xy, r2.ywyy, r2.xzxx
    or r2.x, r2.y, r2.x

#line 133
    ult r2.y, icb[r2.x + 0].x, l(4)
    movc r5.z, r2.y, l(0), l(1)
    mov r2.y, icb[r2.x + 0].x
    mov r5.xy, icb[r2.y + 12].xyxx
    iadd r3.yzw, r5.xxyz, vThreadID.xxyz

#line 82
    imad r2.y, r3.z, cb0[0].x, r3.y
    imad r2.y, r3.w, r0.w, r2.y  // r2.y <- <CalculateVoxelVolumeIndex_id11 return value>

#line 114
    ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r2.y, r2.y, l(0), u0.xxxx  // r2.y <- <GetVoxel_id12 return value>.valueAndGradient.x

#line 134
    mov r2.x, icb[r2.x + 0].y
    iadd r3.yzw, vThreadID.xxyz, icb[r2.x + 12].xxyz

#line 82
    imad r2.x, r3.z, cb0[0].x, r3.y
    imad r2.x, r3.w, r0.w, r2.x  // r2.x <- <CalculateVoxelVolumeIndex_id11 return value>

#line 114
    ld_structured_indexable(structured_buffer, stride=16)(mixed,mixed,mixed,mixed) r2.x, r2.x, l(0), u0.xxxx  // r2.x <- <GetVoxel_id12 return value>.valueAndGradient.x

#line 110
    ge r2.yz, r2.yyxy, l(0.000000, 0.000000, 0.000000, 0.000000)
    and r2.yz, r2.yyzy, l(0, 1, 1, 0)  // r2.z <- <IsSolid_id8 return value>

#line 135
    ieq r2.y, r2.z, r2.y
    if_nz r2.y

#line 137
      iadd r2.y, r1.w, l(1)  // r2.y <- index
      mov r1.w, r2.y  // r1.w <- index
      continue 

#line 138
    endif 

#line 105
    iadd r2.y, r3.x, l(5)
    movc r2.y, r4.x, l(1), r2.y
    ult r2.z, r2.y, l(4)
    movc r3.z, r2.z, l(0), l(1)
    mov r3.xy, icb[r2.y + 12].xyxx
    iadd r3.xyz, r3.xyzx, vThreadID.xyzx

#line 69
    ieq r4.xyz, r3.xyzx, l(0, 0, 0, 0)
    ieq r5.xyz, r1.xyzx, r3.xyzx
    or r4.xyz, r4.xyzx, r5.xyzx
    or r2.y, r4.y, r4.x
    or r2.y, r4.z, r2.y

#line 77
    iadd r4.xyz, r3.xyzx, l(-1, -1, -1, 0)
    udiv r4.xyz, null, r4.xyzx, cb0[1].wwww
    imad r4.xyz, r4.xyzx, cb0[1].wwww, l(1, 1, 1, 0)
    movc r3.xyz, r2.yyyy, r3.xyzx, r4.xyzx

#line 78
    imad r2.y, r3.y, cb0[0].x, r3.x
    imad r2.y, r3.z, r0.w, r2.y  // r2.y <- <CalculateCellVertexInfoLookupTableIndex_id21 return value>

#line 105
    ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r2.y, r2.y, l(0), u1.xxxx
    mov x0[0].x, r2.y
    mov r2.y, icb[r1.w + 20].y
    iadd r3.xyz, vThreadID.xyzx, icb[r2.y + 12].xyzx

#line 69
    ieq r4.xyz, r3.xyzx, l(0, 0, 0, 0)
    ieq r5.xyz, r1.xyzx, r3.xyzx
    or r4.xyz, r4.xyzx, r5.xyzx
    or r2.y, r4.y, r4.x
    or r2.y, r4.z, r2.y

#line 77
    iadd r4.xyz, r3.xyzx, l(-1, -1, -1, 0)
    udiv r4.xyz, null, r4.xyzx, cb0[1].wwww
    imad r4.xyz, r4.xyzx, cb0[1].wwww, l(1, 1, 1, 0)
    movc r3.xyz, r2.yyyy, r3.xyzx, r4.xyzx

#line 78
    imad r2.y, r3.y, cb0[0].x, r3.x
    imad r2.y, r3.z, r0.w, r2.y  // r2.y <- <CalculateCellVertexInfoLookupTableIndex_id21 return value>

#line 105
    ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r2.y, r2.y, l(0), u1.xxxx
    mov x0[1].x, r2.y
    mov r2.y, icb[r1.w + 20].z
    iadd r3.xyz, vThreadID.xyzx, icb[r2.y + 12].xyzx

#line 69
    ieq r4.xyz, r3.xyzx, l(0, 0, 0, 0)
    ieq r5.xyz, r1.xyzx, r3.xyzx
    or r4.xyz, r4.xyzx, r5.xyzx
    or r2.y, r4.y, r4.x
    or r2.y, r4.z, r2.y

#line 77
    iadd r4.xyz, r3.xyzx, l(-1, -1, -1, 0)
    udiv r4.xyz, null, r4.xyzx, cb0[1].wwww
    imad r4.xyz, r4.xyzx, cb0[1].wwww, l(1, 1, 1, 0)
    movc r3.xyz, r2.yyyy, r3.xyzx, r4.xyzx

#line 78
    imad r2.y, r3.y, cb0[0].x, r3.x
    imad r2.y, r3.z, r0.w, r2.y  // r2.y <- <CalculateCellVertexInfoLookupTableIndex_id21 return value>

#line 105
    ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r2.y, r2.y, l(0), u1.xxxx
    mov x0[2].x, r2.y

#line 143
    lt r2.x, r2.x, l(0.000000)

#line 141
    mov r2.y, l(0)  // r2.y <- triangleIndex
    loop 
      uge r2.z, r2.y, l(2)
      breakc_nz r2.z

#line 143
      iadd r2.z, r2.y, l(1)
      movc r3.x, r2.x, r2.y, r2.z
      mov r0.z, x0[r3.x + 0].x  // r0.z <- firstNeighbourCellVertexInfo

#line 144
      iadd r3.x, -r2.x, r2.y
      mov r0.y, x0[r3.x + 0].x  // r0.y <- secondNeighbourCellVertexInfo

#line 73
      ine r3.xyz, r0.yzzy, r0.xxyx
      and r3.x, r3.y, r3.x
      and r3.x, r3.z, r3.x  // r3.x <- <ArePairwiseDistinct_id28 return value>

#line 91
      if_nz r3.x
        imm_atomic_alloc r3.x, u1
        store_structured u2.xyz, r3.x, l(0), r0.xyzx
      endif 

#line 146
      mov r2.y, r2.z
    endloop 

#line 130
    iadd r1.w, r1.w, l(1)

#line 147
  endloop 
endif 

#line 162
ret 
// Approximately 125 instruction slots used
***************************
*************************/
static const uint numberOfCellCorners_id12 = 8;
static const uint3 cellCorners_id13[numberOfCellCorners_id12] = { uint3(0, 0, 0), uint3(0, 1, 0), uint3(1, 1, 0), uint3(1, 0, 0), uint3(0, 0, 1), uint3(0, 1, 1), uint3(1, 1, 1), uint3(1, 0, 1)};
static const uint numberOfCellEdges_id14 = 12;
static const uint2 cellEdges_id15[numberOfCellEdges_id14] = { uint2(0, 3), uint2(3, 7), uint2(7, 4), uint2(4, 0), uint2(1, 2), uint2(2, 6), uint2(5, 6), uint2(5, 1), uint2(0, 1), uint2(3, 2), uint2(7, 6), uint2(4, 5)};
static const uint maxNumberOfIntersections_id21 = 6;
struct CS_STREAMS 
{
    uint3 GroupId_id0;
    uint3 DispatchThreadId_id1;
    int ThreadCountX_id7;
    int ThreadCountY_id8;
    int ThreadCountZ_id9;
    uint ThreadCountPerGroup_id5;
    uint3 ThreadGroupCount_id4;
    uint ThreadGroupIndex_id6;
};
struct CS_INPUT 
{
    uint3 GroupId_id0 : SV_GroupID;
    uint3 DispatchThreadId_id1 : SV_DispatchThreadID;
};
struct Vertex 
{
    float3 position;
    float3 normal;
};
struct Voxel 
{
    float4 valueAndGradient;
};
struct CellVertexInfo 
{
    uint index;
};
struct Intersection 
{
    float3 position;
    float3 normal;
    uint materialIndex;
};
cbuffer PerDispatch 
{
    int3 ThreadGroupCountGlobal_id10;
};
cbuffer Globals 
{
    int3 NumberOfVoxels_id17;
    float VoxelSpacing_id18;
    float3 VolumeOffset_id19;
    uint cellStride_id22 = 1;
    uint schmitzParticleIterations_id23 = 20;
    float schmitzParticleStepSize_id24 = 0.2f;
    bool UseSDFNormal_id25;
    static uint numberOfIntersections_id31;
    static Intersection intersections_id32[maxNumberOfIntersections_id21];
    static uint numberOfMaterialIndices_id33;
    static uint materialIndices_id34[numberOfCellCorners_id12];
    static float3 forces_id35[numberOfCellCorners_id12];
    static CellVertexInfo neighbourCellVertexInfos_id36[3];
};
RWStructuredBuffer<Voxel> VoxelVolume_id16;
RWStructuredBuffer<CellVertexInfo> cellVertexInfoLookupTable_id26;
RWStructuredBuffer<Vertex> generatedVertices_id27;
RWStructuredBuffer<float4> generatedVerticesCounter_id28;
RWStructuredBuffer<Vertex> generatedVertices1_id29;
RWStructuredBuffer<uint3> generatedTriangles_id30;
bool IsOuterVoxel_id20(uint3 coordinate)
{
    return any(coordinate == 0 || coordinate == NumberOfVoxels_id17 - 2);
}
bool ArePairwiseDistinct_id28(uint3 indices)
{
    return indices.x != indices.y && indices.x != indices.z && indices.y != indices.z;
}
uint CalculateCellVertexInfoLookupTableIndex_id21(uint3 coordinate, uint stride = 1)
{
    coordinate = IsOuterVoxel_id20(coordinate) ? coordinate : (coordinate - 1) / stride * stride + 1;
    return dot(coordinate, uint3(1, NumberOfVoxels_id17.x, (NumberOfVoxels_id17.x) * (NumberOfVoxels_id17.y)));
}
uint CalculateVoxelVolumeIndex_id11(uint3 coordinate)
{
    return dot(coordinate, uint3(1, NumberOfVoxels_id17.x, NumberOfVoxels_id17.x * NumberOfVoxels_id17.y));
}
void GenerateTriangle_id29(CellVertexInfo cellVertexInfo, CellVertexInfo firstNeighbourCellVertexInfo, CellVertexInfo secondNeighbourCellVertexInfo)
{
    uint3 indices = uint3(cellVertexInfo.index, secondNeighbourCellVertexInfo.index, firstNeighbourCellVertexInfo.index);
    if (!ArePairwiseDistinct_id28(indices))
    {
        return;
    }
    generatedTriangles_id30[cellVertexInfoLookupTable_id26.IncrementCounter()] = indices;
}
float GetValue_id4(Voxel v)
{
    return v.valueAndGradient.x;
}
void GetNeighbourCellsVertexInfos_id30(uint3 coordinate, uint index)
{
    const uint3 cellCornerIndices[3] = { uint3(1, 2, 3), uint3(4, 5, 1), uint3(3, 7, 4)};
    uint3 vertexIndices;

    [unroll]
    for (uint iterator = 0; iterator < 3; iterator++)
    {
        neighbourCellVertexInfos_id36[iterator] = cellVertexInfoLookupTable_id26[CalculateCellVertexInfoLookupTableIndex_id21(coordinate + cellCorners_id13[cellCornerIndices[index][iterator]], cellStride_id22)];
    }
}
uint IsSolid_id8(Voxel v)
{
    return v.valueAndGradient.x >= 0.0;
}
Voxel GetVoxel_id12(uint3 coordinate)
{
    return VoxelVolume_id16[CalculateVoxelVolumeIndex_id11(coordinate)];
}
uint2 GetCellEdge_id31(uint index)
{
    const uint3 edgeIndices = uint3(5, 6, 10);
    return cellEdges_id15[edgeIndices[index]];
}
void Compute_id32(inout CS_STREAMS streams)
{
    uint3 cellID = streams.DispatchThreadId_id1;
    if (any(cellID > NumberOfVoxels_id17 - 3))
    {
        return;
    }
    CellVertexInfo cellVertexInfo = cellVertexInfoLookupTable_id26[CalculateCellVertexInfoLookupTableIndex_id21(cellID, cellStride_id22)];

    for (uint index = 0; index < 3; index++)
    {
        uint2 cellEdge = GetCellEdge_id31(index);
        Voxel sampleA = GetVoxel_id12(cellID + cellCorners_id13[cellEdge.x]);
        Voxel sampleB = GetVoxel_id12(cellID + cellCorners_id13[cellEdge.y]);
        if (IsSolid_id8(sampleA) == IsSolid_id8(sampleB))
        {
            continue;
        }
        GetNeighbourCellsVertexInfos_id30(cellID, index);

        for (uint triangleIndex = 0; triangleIndex < 2; triangleIndex++)
        {
            CellVertexInfo firstNeighbourCellVertexInfo = neighbourCellVertexInfos_id36[GetValue_id4(sampleB) < 0.0f ? triangleIndex : triangleIndex + 1];
            CellVertexInfo secondNeighbourCellVertexInfo = neighbourCellVertexInfos_id36[GetValue_id4(sampleB) < 0.0f ? triangleIndex + 1 : triangleIndex];
            GenerateTriangle_id29(cellVertexInfo, firstNeighbourCellVertexInfo, secondNeighbourCellVertexInfo);
        }
    }
}
[numthreads(1, 1, 1)]
void CSMain(CS_INPUT __input__)
{
    CS_STREAMS streams = (CS_STREAMS)0;
    streams.GroupId_id0 = __input__.GroupId_id0;
    streams.DispatchThreadId_id1 = __input__.DispatchThreadId_id1;
    streams.ThreadCountX_id7 = 1;
    streams.ThreadCountY_id8 = 1;
    streams.ThreadCountZ_id9 = 1;
    streams.ThreadCountPerGroup_id5 = 1 * 1 * 1;
    streams.ThreadGroupCount_id4 = ThreadGroupCountGlobal_id10;
    streams.ThreadGroupIndex_id6 = (streams.GroupId_id0.z * streams.ThreadGroupCount_id4.y + streams.GroupId_id0.y) * streams.ThreadGroupCount_id4.x + streams.GroupId_id0.x;
    Compute_id32(streams);
}
