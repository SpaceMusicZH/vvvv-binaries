/**************************
***** Compiler Parameters *****
***************************
@P EffectName: ComputeEffectShader
@P   - ComputeEffectShader.ThreadNumbers: X:256 Y:1 Z:1
@P ComputeEffectShader.ComputeShaderName: HistogramReduce
***************************
****  ConstantBuffers  ****
***************************
cbuffer Globals [Size: 32]
@C    TimeDelta_id13 => HistogramReduce.TimeDelta
@C    Tau_id14 => HistogramReduce.Tau
@C    PixelCount_id15 => HistogramReduce.PixelCount
@C    AutoKey_id16 => HistogramReduce.AutoKey
@C    TargetLuminance_id17 => HistogramReduce.TargetLuminance
@C    MinExposure_id18 => HistogramReduce.MinExposure
@C    MaxExposure_id19 => HistogramReduce.MaxExposure
***************************
******  Resources    ******
***************************
@R    Histogram_id11 => HistogramReduce.Histogram [Stage: Compute, Slot: (0-0)]
@R    Exposure_id12 => HistogramReduce.Exposure [Stage: Compute, Slot: (0-0)]
@R    Globals => Globals [Stage: Compute, Slot: (0-0)]
***************************
*****     Sources     *****
***************************
@S    ComputeShaderBase => 8f045851eaa4513eb38a704d53889e6d
@S    HistogramReduce => dd4d6de91f9417fd41d429b1adbb0ede
@S    PostEffectCommon => af38cf1814fc29be0c21f6c2a879be01
@S    Histogram => 85e15bf727f0cb54f429385a45336686
***************************
*****     Stages      *****
***************************
@G    Compute => 4fc4e8ad5ed21dc3598e12779cfc0298
//
// Generated by Microsoft (R) HLSL Shader Compiler 10.1
//
//
// Buffer Definitions: 
//
// cbuffer Globals
// {
//
//   float TimeDelta_id13;              // Offset:    0 Size:     4
//   float Tau_id14;                    // Offset:    4 Size:     4
//      = 0x3f8ccccd 
//   uint PixelCount_id15;              // Offset:    8 Size:     4
//   bool AutoKey_id16;                 // Offset:   12 Size:     4
//      = 0xffffffff 
//   float TargetLuminance_id17;        // Offset:   16 Size:     4
//      = 0x3da3d70a 
//   float MinExposure_id18;            // Offset:   20 Size:     4
//      = 0x3c800000 
//   float MaxExposure_id19;            // Offset:   24 Size:     4
//      = 0x42800000 
//
// }
//
// Resource bind info for Exposure_id12
// {
//
//   float $Element;                    // Offset:    0 Size:     4
//
// }
//
//
// Resource Bindings:
//
// Name                                 Type  Format         Dim      HLSL Bind  Count
// ------------------------------ ---------- ------- ----------- -------------- ------
// Histogram_id11                    texture    byte         r/o             t0      1 
// Exposure_id12                         UAV  struct         r/w             u0      1 
// Globals                           cbuffer      NA          NA            cb0      1 
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// no Input
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// no Output
cs_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer CB0[2], immediateIndexed
dcl_resource_raw t0
dcl_uav_structured u0, 4
dcl_input vThreadIDInGroupFlattened
dcl_temps 2
dcl_tgsm_structured g0, 4, 256
dcl_thread_group 256, 1, 1
//
// Initial variable locations:
//   vThreadGroupID.x <- __input__.GroupId_id0.x; vThreadGroupID.y <- __input__.GroupId_id0.y; vThreadGroupID.z <- __input__.GroupId_id0.z; 
//   vThreadIDInGroupFlattened.x <- __input__.GroupIndex_id3
//
#line 36 "H:\JHH_SpaceMusic\SpaceMusicZH\vvvv-binaries\vvvv_gamma\log\shader_ComputeEffectShader_48c142aae28be26e90ddb10188de3f4a.hlsl"
ishl r0.x, vThreadIDInGroupFlattened.x, l(2)
ld_raw_indexable(raw_buffer)(mixed,mixed,mixed,mixed) r0.x, r0.x, t0.xxxx
utof r0.x, r0.x
utof r0.y, vThreadIDInGroupFlattened.x
mul r0.x, r0.y, r0.x  // r0.x <- weightedSum

#line 39
mov r0.y, r0.x  // r0.y <- weightedSum
mov r0.z, l(1)  // r0.z <- i
loop 
  uge r0.w, r0.z, l(256)
  breakc_nz r0.w

#line 41
  store_structured g0.x, vThreadIDInGroupFlattened.x, l(0), r0.y

#line 42
  sync_g_t

#line 43
  iadd r0.w, r0.z, vThreadIDInGroupFlattened.x
  and r0.w, r0.w, l(255)
  ld_structured r0.w, r0.w, l(0), g0.xxxx
  add r0.y, r0.w, r0.y

#line 44
  sync_g_t

#line 45
  ishl r0.z, r0.z, l(1)
endloop 

#line 48
ne r0.x, r0.y, l(0.000000)
if_nz r0.x
  if_z vThreadIDInGroupFlattened.x

#line 50
    ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r1.x, l(4), l(0), u0.xxxx  // r1.x <- MinLog

#line 51
    ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r1.y, l(5), l(0), u0.xxxx  // r1.y <- MaxLog

#line 52
    ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, l(6), l(0), u0.xxxx  // r0.x <- LogRange

#line 53
    ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.z, l(7), l(0), u0.xxxx  // r0.z <- RcpLogRange

#line 54
    ld_raw_indexable(raw_buffer)(mixed,mixed,mixed,mixed) r0.w, l(0), t0.xxxx
    iadd r0.w, -r0.w, cb0[0].z
    umax r0.w, r0.w, l(1)
    utof r0.w, r0.w
    div r0.y, r0.y, r0.w
    add r0.y, r0.y, l(-1.000000)  // r0.y <- weightedLogAverage

#line 55
    mul r0.w, r0.x, r0.y
    mad r0.w, r0.w, l(0.003937), r1.x
    exp r0.w, r0.w  // r0.w <- weightedAverageLuminance

#line 59
    add r1.z, r0.w, l(1.000000)
    log r1.z, r1.z
    mad r1.z, r1.z, l(0.693147), l(2.000000)
    div r1.z, l(2.000000), r1.z
    add r1.z, -r1.z, l(1.030000)  // r1.z <- targetLuminance

#line 60
    movc r1.z, cb0[0].w, r1.z, cb0[1].x

#line 61
    div r0.w, r1.z, r0.w  // r0.w <- targetExposure

#line 62
    ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r1.z, l(0), l(0), u0.xxxx  // r1.z <- exposure

#line 63
    add r0.w, r0.w, -r1.z
    mul r1.w, cb0[0].y, -cb0[0].x
    mul r1.w, r1.w, l(1.442695)
    exp r1.w, r1.w
    add r1.w, -r1.w, l(1.000000)
    mad r0.w, r0.w, r1.w, r1.z  // r0.w <- exposure

#line 64
    max r0.w, r0.w, cb0[1].y
    min r0.w, r0.w, cb0[1].z  // r0.w <- exposure

#line 65
    store_structured u0.x, l(0), l(0), r0.w

#line 66
    div r1.z, l(1.000000, 1.000000, 1.000000, 1.000000), r0.w
    store_structured u0.x, l(1), l(0), r1.z

#line 67
    store_structured u0.x, l(2), l(0), r0.w

#line 68
    store_structured u0.x, l(3), l(0), r0.y

#line 69
    round_ni r0.y, r0.y
    add r0.y, r0.y, l(-128.000000)
    mul r0.y, r0.y, l(0.003922)  // r0.y <- biasToCenter

#line 70
    lt r0.w, l(0.100000), |r0.y|

#line 73
    mad r0.yz, r0.yyyy, r0.zzzz, r1.xxyx  // r0.y <- MinLog; r0.z <- MaxLog

#line 74
    movc r0.yz, r0.wwww, r0.yyzy, r1.xxyx

#line 75
    store_structured u0.x, l(4), l(0), r0.y

#line 76
    store_structured u0.x, l(5), l(0), r0.z

#line 78
    div r0.x, l(1.000000, 1.000000, 1.000000, 1.000000), r0.x
    store_structured u0.x, l(7), l(0), r0.x

#line 79
  endif 
endif 

#line 94
ret 
// Approximately 69 instruction slots used
***************************
*************************/
struct CS_STREAMS 
{
    uint3 GroupId_id0;
    uint GroupIndex_id3;
    int ThreadCountX_id7;
    int ThreadCountY_id8;
    int ThreadCountZ_id9;
    uint ThreadCountPerGroup_id5;
    uint3 ThreadGroupCount_id4;
    uint ThreadGroupIndex_id6;
};
struct CS_INPUT 
{
    uint3 GroupId_id0 : SV_GroupID;
    uint GroupIndex_id3 : SV_GroupIndex;
};
cbuffer PerDispatch 
{
    int3 ThreadGroupCountGlobal_id10;
};
cbuffer Globals 
{
    float TimeDelta_id13;
    float Tau_id14 = 1.1f;
    uint PixelCount_id15;
    bool AutoKey_id16 = true;
    float TargetLuminance_id17 = 0.08f;
    float MinExposure_id18 = 1.0f / 64.0f;
    float MaxExposure_id19 = 64.0f;
    groupshared float HistogramShared_id20[256];
};
ByteAddressBuffer Histogram_id11;
RWStructuredBuffer<float> Exposure_id12;
void Compute_id5(inout CS_STREAMS streams)
{
    float weightedSum = (float)Histogram_id11.Load(streams.GroupIndex_id3 * 4) * float(streams.GroupIndex_id3);
    GroupMemoryBarrierWithGroupSync();

    for (uint i = 1; i < 256; i *= 2)
    {
        HistogramShared_id20[streams.GroupIndex_id3] = weightedSum;
        GroupMemoryBarrierWithGroupSync();
        weightedSum += HistogramShared_id20[(streams.GroupIndex_id3 + i) % 256];
        GroupMemoryBarrierWithGroupSync();
    }
    if (weightedSum == 0.0f)
        return;
    if (streams.GroupIndex_id3 == 0)
    {
        float MinLog = Exposure_id12[4];
        float MaxLog = Exposure_id12[5];
        float LogRange = Exposure_id12[6];
        float RcpLogRange = Exposure_id12[7];
        float weightedLogAverage = weightedSum / (max(1, PixelCount_id15 - Histogram_id11.Load(0))) - 1.0;
        float weightedAverageLuminance = exp2(((weightedLogAverage / 254.0) * LogRange) + MinLog);
        float targetLuminance = TargetLuminance_id17;
        if (AutoKey_id16)
        {
            targetLuminance = 1.03f - (2.0f / (2.0f + (log(weightedAverageLuminance + 1) / log(exp(1)))));
        }
        float targetExposure = targetLuminance / weightedAverageLuminance;
        float exposure = Exposure_id12[0];
        exposure = exposure + (targetExposure - exposure) * (1 - exp(-TimeDelta_id13 * Tau_id14));
        exposure = clamp(exposure, MinExposure_id18, MaxExposure_id19);
        Exposure_id12[0] = exposure;
        Exposure_id12[1] = 1.0 / exposure;
        Exposure_id12[2] = exposure;
        Exposure_id12[3] = weightedLogAverage;
        float biasToCenter = (floor(weightedLogAverage) - 128.0) / 255.0;
        if (abs(biasToCenter) > 0.1)
        {
            MinLog += biasToCenter * RcpLogRange;
            MaxLog += biasToCenter * RcpLogRange;
        }
        Exposure_id12[4] = MinLog;
        Exposure_id12[5] = MaxLog;
        Exposure_id12[6] = LogRange;
        Exposure_id12[7] = 1.0 / LogRange;
    }
}
[numthreads(256, 1, 1)]
void CSMain(CS_INPUT __input__)
{
    CS_STREAMS streams = (CS_STREAMS)0;
    streams.GroupId_id0 = __input__.GroupId_id0;
    streams.GroupIndex_id3 = __input__.GroupIndex_id3;
    streams.ThreadCountX_id7 = 256;
    streams.ThreadCountY_id8 = 1;
    streams.ThreadCountZ_id9 = 1;
    streams.ThreadCountPerGroup_id5 = 256 * 1 * 1;
    streams.ThreadGroupCount_id4 = ThreadGroupCountGlobal_id10;
    streams.ThreadGroupIndex_id6 = (streams.GroupId_id0.z * streams.ThreadGroupCount_id4.y + streams.GroupId_id0.y) * streams.ThreadGroupCount_id4.x + streams.GroupId_id0.x;
    Compute_id5(streams);
}
